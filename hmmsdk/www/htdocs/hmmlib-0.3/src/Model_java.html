<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML lang="en"><HEAD>
<META http-equiv="Generator" content="com.bluecraft.htmlize">
<TITLE>Source Code: Model.java</TITLE>
<STYLE>
body {
    background: ivory;
    color: black;
}
DIV.description {
    color: maroon;
    margin-top: -0.4cm;
}
SPAN.linenumber {
    color: maroon;
}
SPAN.string {
    color: red;
}
SPAN.comment {
    color: green;
}
SPAN.keyword {
    color: blue;
}
SPAN.userkeyword {
    color: purple;
    font-weight: bold;
}
</STYLE>
</HEAD><BODY>
<H2>Model.java</H2>
<DIV class="description">
Generated by <STRONG>com.bluecraft.htmlize</STRONG> HTML-ization Utility Classes.
</DIV>
<PRE>
<SPAN class="comment">//////////////////////////////////////////////////////////////////////////
</SPAN><SPAN class="comment">// The contents of this file are subject to the Mozilla Public License
</SPAN><SPAN class="comment">// Version 1.0 (the "License"); you may not use this file except in
</SPAN><SPAN class="comment">// compliance with the License. You may obtain a copy of the License at
</SPAN><SPAN class="comment">// http://www.mozilla.org/MPL/
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// Software distributed under the License is distributed on an "AS IS"
</SPAN><SPAN class="comment">// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
</SPAN><SPAN class="comment">// License for the specific language governing rights and limitations under
</SPAN><SPAN class="comment">// the License.
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// The Original Code is Hidden Markov Model Library in Java.
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// The Initial Developer of the Original Code is Hyoungsoo Yoon.
</SPAN><SPAN class="comment">// Portions created by Hyoungsoo Yoon are
</SPAN><SPAN class="comment">// Copyright (C) 1999 Hyoungsoo Yoon.  All Rights Reserved.
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// Contributor(s):
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">//////////////////////////////////////////////////////////////////////////
</SPAN>

<SPAN class="comment">/**
Hidden Markov Model Library in Java.
Please refer to Rabiner 1989.
All algorithms are directly taken from this article.
Notations and variable names also closely follow the conventions used in this paper.

@copyright  Hyoungsoo Yoon
@date  Feb 21st, 1999
*/</SPAN>
<SPAN class="keyword">package</SPAN> com.bluecraft.hmm;


<SPAN class="keyword">import</SPAN> com.bluecraft.hmm.util.*;
<SPAN class="keyword">import</SPAN> org.w3c.dom.*;
<SPAN class="keyword">import</SPAN> java.util.*;
<SPAN class="keyword">import</SPAN> java.io.*;

<SPAN class="comment">/**
Markov model with symbol-generation probabilities.
The class Hmm is built on top of this class.
Please refer to Rabiner 1989.

@author  Hyoungsoo Yoon
@version  0.3
*/</SPAN>
<SPAN class="keyword">public</SPAN> <SPAN class="keyword">class</SPAN> Model <SPAN class="keyword">implements</SPAN> Serializable, XmlParserList {

    <SPAN class="comment">//&lt;Static_Fields&gt;
</SPAN>    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">final</SPAN> <SPAN class="keyword">int</SPAN> MAX_NUM_STATES = 1000;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">final</SPAN> <SPAN class="keyword">int</SPAN> MAX_NUM_SYMBOLS = 1000;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">double</SPAN> MIN_PROB = 0.00001;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> Random rand = <SPAN class="keyword">new</SPAN> Random();
    <SPAN class="comment">//&lt;/Static_Fields&gt;
</SPAN>    
    <SPAN class="comment">//&lt;Static_Methods&gt;
</SPAN>    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">int</SPAN> getMaxNumStates() {
        <SPAN class="keyword">return</SPAN> MAX_NUM_STATES;
    }
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">int</SPAN> getMaxNumSymbols() {
        <SPAN class="keyword">return</SPAN> MAX_NUM_SYMBOLS;
    }
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">double</SPAN> getMinProb() {
        <SPAN class="keyword">return</SPAN> MIN_PROB;
    }
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">double</SPAN> setMinProb(<SPAN class="keyword">double</SPAN> p) {
        <SPAN class="keyword">if</SPAN>(p &gt;= 0.0 &amp;&amp; p &lt; 1.0) {
            MIN_PROB = p;
        }
        <SPAN class="keyword">return</SPAN> MIN_PROB;
    }
    <SPAN class="comment">//&lt;/Static_Methods&gt;
</SPAN>

    <SPAN class="comment">//&lt;Private_Fields&gt;
</SPAN>    <SPAN class="comment">/**
    @serial
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">int</SPAN>  num_states = 0;
    <SPAN class="comment">/**
    @serial
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">int</SPAN>  num_symbols = 0;
    <SPAN class="comment">/**
    @serial
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">int</SPAN>  ll_bound = 0;
    <SPAN class="comment">/**
    @serial
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">int</SPAN>  ur_bound = 0;
    
    <SPAN class="comment">/**
    @serial  Transition probability (num_states x num_states)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[][] a;  
    <SPAN class="comment">/**
    @serial  Symbol generating probability (num_states x num_symbols)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[][] b; 
    <SPAN class="comment">/**
    @serial  Initial state probability (1 x num_states)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[] pi;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">transient</SPAN> <SPAN class="keyword">int</SPAN>[] l_limit;      <SPAN class="comment">// a[][] has a band of non-zero elements
</SPAN>    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">transient</SPAN> <SPAN class="keyword">int</SPAN>[] r_limit;     <SPAN class="comment">// For each row, columns below l_limit and above r_limit are zero
</SPAN>    <SPAN class="comment">//&lt;/Private_Fields&gt;
</SPAN>

    <SPAN class="comment">//&lt;Protectd_Fields&gt;
</SPAN>    <SPAN class="comment">//&lt;/Protectd_Fields&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Public_Fields&gt;
</SPAN>    <SPAN class="comment">//&lt;/Public_Fields&gt;
</SPAN>

    <SPAN class="comment">//&lt;Constructors&gt;
</SPAN>    <SPAN class="comment">/**
    Construct Model with a minimum size (number of states: 1, number of symbols: 1).
    The elements of the matrices are initialized by random values.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model() {
        <SPAN class="keyword">this</SPAN>(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Construct Model with a minimum size (number of states: 1, number of symbols: 1).
    @param bRandomize If true, the elements of the matrices are initialized by random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">this</SPAN>(1,1,bRandomize);
    }
    <SPAN class="comment">/**
    Construct Model by specifying dimensions.
    The elements of the matrices are initialized by random values.
    @param nstates Number of states of a Markov model
    @param nsymbols Number of symbols generated by the model
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model(<SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols) {
        <SPAN class="keyword">this</SPAN>(nstates, nsymbols, <SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Construct Model by specifying dimensions.
    @param nstates Number of states of a Markov model
    @param nsymbols Number of symbols generated by the model
    @param bRandomize If true, the elements of the matrices are initialized by random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model(<SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols, <SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">this</SPAN>(nstates, nsymbols, nstates-1, nstates-1, bRandomize);
    }
    <SPAN class="comment">/**
    Construct Model by specifying dimensions.
    The elements of the matrices are initialized by random values.
    @param nstates Number of states of a Markov model
    @param nsymbols Number of symbols generated by the model
    @param llb Lower-left bound of the non-zero band of the transition matrix (diagonal: 0)
    @param urb Upper-right bound of the non-zero band of the transition matrix (diagonal: 0)
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model(<SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols, <SPAN class="keyword">int</SPAN> llb, <SPAN class="keyword">int</SPAN> urb) {
        <SPAN class="keyword">this</SPAN>(nstates, nsymbols, llb, urb, <SPAN class="keyword">true</SPAN>);
    }    
    <SPAN class="comment">/**
    Construct Model by specifying dimensions.
    @param nstates Number of states of a Markov model
    @param nsymbols Number of symbols generated by the model
    @param llb Lower-left bound of the non-zero band of the transition matrix (diagonal: 0)
    @param urb Upper-right bound of the non-zero band of the transition matrix (diagonal: 0)
    @param bRandomize If true, the elements of the matrices are initialized by random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model(<SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols, <SPAN class="keyword">int</SPAN> llb, <SPAN class="keyword">int</SPAN> urb, <SPAN class="keyword">boolean</SPAN> bRandomize) {
        num_states = nstates;
        num_symbols = nsymbols;
        
        a = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states][num_states];
        b = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states][num_symbols];
        pi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states];
        l_limit = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[num_states];
        r_limit = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[num_states];
        
        ll_bound = (llb &lt; num_states &amp;&amp; llb &gt;= 0) ? llb : (num_states-1);
        ur_bound = (urb &lt; num_states &amp;&amp; urb &gt;= 0) ? urb : (num_states-1);
        setLimits();
        setProbability(bRandomize);
    }
    <SPAN class="comment">/**
    Construct Model by loading model parameters from an XML file.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model(String file) {
        <SPAN class="keyword">this</SPAN>(file, <SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Construct Model by loading model parameters from a file.
    @param file Name of input file
    @param bXml If true, read input file in XML format
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Model(String file, <SPAN class="keyword">boolean</SPAN> bXml) {
        <SPAN class="keyword">if</SPAN>(bXml) {
            loadModelXml(file);
        } <SPAN class="keyword">else</SPAN> {
            loadModelAscii(file);
        }
    }
    <SPAN class="comment">//&lt;/Constructors&gt;
</SPAN>

    <SPAN class="comment">//&lt;Private_Methods&gt;
</SPAN>    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> setLimits() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
            l_limit[i] = (i-ll_bound &gt;=0) ? (i-ll_bound) : 0;
            r_limit[i] = (i+ur_bound &lt;= num_states-1) ? (i+ur_bound) : (num_states-1);
        }
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> setLeftRight(<SPAN class="keyword">int</SPAN> llb, <SPAN class="keyword">int</SPAN> urb) {
        ll_bound = (llb &lt; num_states &amp;&amp; llb &gt;= 0) ? llb : (num_states-1);
        ur_bound = (urb &lt; num_states &amp;&amp; urb &gt;= 0) ? urb : (num_states-1);
        setLimits();
        resetA();
    }    

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> clearA() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
                a[i][j] = 0.0;
            }
        }
    }    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> clearB() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
                b[i][k] = 0.0;
            }
        }
    }    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> clearPi() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
            pi[j] = 0.0;
        }
    }    

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> resetA() {
        resetA(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> resetA(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        clearA();
        setA(bRandomize);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> resetB() {
        resetB(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> resetB(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        clearB();
        setB(bRandomize);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> resetPi() {
        resetPi(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> resetPi(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        clearPi();
        setPi(bRandomize);
    }

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> normalizeRowA(<SPAN class="keyword">int</SPAN> i) <SPAN class="keyword">throws</SPAN> ProbabilityUnnormalizableException {        
        <SPAN class="keyword">double</SPAN> sum = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=l_limit[i];j&lt;=r_limit[i];j++) {
            sum += a[i][j];
        }
        sum -= (r_limit[i] - l_limit[i] + 1) * MIN_PROB;
        <SPAN class="keyword">if</SPAN>(sum &lt;= 0.0) {
            <SPAN class="keyword">throw</SPAN> <SPAN class="keyword">new</SPAN> ProbabilityUnnormalizableException(<SPAN class="string">"A: Row "</SPAN> + i + <SPAN class="string">" unnormalizable!"</SPAN>);
        }    
        <SPAN class="keyword">double</SPAN> factor = (1.0 - (r_limit[i] - l_limit[i] + 1) * MIN_PROB)/sum;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=l_limit[i];j&lt;=r_limit[i];j++) {
            a[i][j] *= factor;
            a[i][j] += (1.0 - factor) * MIN_PROB;
        }
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> normalizeRowA() <SPAN class="keyword">throws</SPAN> ProbabilityUnnormalizableException {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
            normalizeRowA(i);
        }
    }    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> normalizeRowB(<SPAN class="keyword">int</SPAN> i) <SPAN class="keyword">throws</SPAN> ProbabilityUnnormalizableException {        
        <SPAN class="keyword">double</SPAN> sum = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
            sum += b[i][k];
        }
        sum -= num_symbols * MIN_PROB;
        <SPAN class="keyword">if</SPAN>(sum &lt;= 0.0) {
            <SPAN class="keyword">throw</SPAN> <SPAN class="keyword">new</SPAN> ProbabilityUnnormalizableException(<SPAN class="string">"B: Row "</SPAN> + i + <SPAN class="string">" unnormalizable!"</SPAN>);
        }    
        <SPAN class="keyword">double</SPAN> factor = (1.0 - num_symbols * MIN_PROB)/sum;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
            b[i][k] *= factor;
            b[i][k] += (1.0 - factor) * MIN_PROB;
        }
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> normalizeRowB() <SPAN class="keyword">throws</SPAN> ProbabilityUnnormalizableException {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
            normalizeRowB(i);
        }
    }    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> normalizeRowPi() <SPAN class="keyword">throws</SPAN> ProbabilityUnnormalizableException {        
        <SPAN class="keyword">double</SPAN> sum = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
            sum += pi[j];
        }
        sum -= num_states * MIN_PROB;
        <SPAN class="keyword">if</SPAN>(sum &lt;= 0.0) {
            <SPAN class="keyword">throw</SPAN> <SPAN class="keyword">new</SPAN> ProbabilityUnnormalizableException(<SPAN class="string">"Pi: Unnormalizable!"</SPAN>);
        }    
        <SPAN class="keyword">double</SPAN> factor = (1.0 - num_states * MIN_PROB)/sum;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
            pi[j] *= factor;
            pi[j] += (1.0 - factor) * MIN_PROB;
        }
    }
    <SPAN class="comment">//&lt;/Private_Methods&gt;
</SPAN>
    
    <SPAN class="comment">//&lt;Protectd_Methods&gt;
</SPAN>    <SPAN class="comment">//&lt;/Protectd_Methods&gt;
</SPAN>

    <SPAN class="comment">//&lt;Public_Methods&gt;
</SPAN>    <SPAN class="comment">/**
    @return  Number of states in the Markov model 
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getNumStates() {
        <SPAN class="keyword">return</SPAN> num_states;
    }
    <SPAN class="comment">/**
    @return  Number of observable symbols 
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getNumSymbols() {
        <SPAN class="keyword">return</SPAN> num_symbols;
    }
    
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @return  Left limit (column number) outside of which the transition probability is zero 
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getLLimit(<SPAN class="keyword">int</SPAN> i) {
        <SPAN class="keyword">return</SPAN> l_limit[i];
    }    
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @return  Right limit (column number) outside of which the transition probability is zero 
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getRLimit(<SPAN class="keyword">int</SPAN> i) {
        <SPAN class="keyword">return</SPAN> r_limit[i];
    }
    
    <SPAN class="comment">/**
    Initialize the state-transition matrix A with random values.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setA() {
        setA(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Initialize the state-transition matrix A.
    @param bRandomize If true, initialize A with random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setA(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">if</SPAN>(bRandomize == <SPAN class="keyword">true</SPAN>) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=l_limit[i];j&lt;=r_limit[i];j++) {
                    a[i][j] = rand.nextDouble() + MIN_PROB;
                }
            }
            <SPAN class="keyword">try</SPAN> {
                normalizeRowA();
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
            }
        }
        <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=l_limit[i];j&lt;=r_limit[i];j++) {
                    a[i][j] = MIN_PROB;
                }
                a[i][i] = 1.0 - (r_limit[i] - l_limit[i])*MIN_PROB;
            }
        }
    }
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @param j Column number of state-transition matrix A
    @param p Probability value    
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setA(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> j, <SPAN class="keyword">double</SPAN> p) {
        a[i][j] = (p&gt;MIN_PROB) ? p : MIN_PROB;
    }
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @param j Column number of state-transition matrix A
    @param p Probability value
    @param bCheck If true, check the index bounds and the range of p
    @return true, if successful
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setA(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> j, <SPAN class="keyword">double</SPAN> p, <SPAN class="keyword">boolean</SPAN> bCheck) {
        <SPAN class="keyword">if</SPAN>((bCheck == <SPAN class="keyword">false</SPAN>) || 
            (i&gt;=0 &amp;&amp; i&lt;num_states &amp;&amp; j&gt;=l_limit[i] &amp;&amp; j&lt;=r_limit[i] &amp;&amp; p&lt;=1.0 &amp;&amp; p&gt;=0.0)) {
            setA(i,j,p);
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
        }
    }
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @param p Row vector of probability values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setA(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">double</SPAN>[] p) {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=l_limit[i];j&lt;=r_limit[i];j++) {
            a[i][j] = (p[j]&gt;MIN_PROB) ? p[j] : MIN_PROB;
        }
    }
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @param p Row vector of probability values
    @param bNormalize If true, renormalize the row in case p is not normalized
    @return false, if A is unnormalized
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setA(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">double</SPAN>[] p, <SPAN class="keyword">boolean</SPAN> bNormalize) {
        setA(i,p);
        <SPAN class="keyword">if</SPAN>(bNormalize == <SPAN class="keyword">false</SPAN>) {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">try</SPAN> {
                normalizeRowA(i);
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
                <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
            }
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        }
    }
    <SPAN class="comment">/**
    @param p Matrix of probability values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setA(<SPAN class="keyword">double</SPAN>[][] p) {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=l_limit[i];j&lt;=r_limit[i];j++) {
                a[i][j] = (p[i][j]&gt;MIN_PROB) ? p[i][j] : MIN_PROB;
            }
        }
    }
    <SPAN class="comment">/**
    @param p Matrix of probability values
    @param bNormalize If true, renormalize each row in case p is not normalized
    @return false, if A is unnormalized
   */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setA(<SPAN class="keyword">double</SPAN>[][] p, <SPAN class="keyword">boolean</SPAN> bNormalize) {
        setA(p);
        <SPAN class="keyword">if</SPAN>(bNormalize == <SPAN class="keyword">false</SPAN>) {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">try</SPAN> {
                normalizeRowA();
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
                <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
            }
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        }
    }
    
    <SPAN class="comment">/**
    Initialize the symbol-generation matrix B with random values.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setB() {
        setB(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Initialize the symbol-generation matrix B.
    @param bRandomize If true, initialize B with random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setB(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">if</SPAN>(bRandomize == <SPAN class="keyword">true</SPAN>) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
                    b[i][k] = rand.nextDouble() + MIN_PROB;
                }
            }    
            <SPAN class="keyword">try</SPAN> {
                normalizeRowB();
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
            }
        }
        <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
                    b[i][k] = 1.0/num_symbols;
                }
            }
        }
    }
    <SPAN class="comment">/**
    @param i Row number of the symbol-generation matrix B
    @param k Column number of symbol-generation matrix B
    @param p Probability value
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setB(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> k, <SPAN class="keyword">double</SPAN> p) {
        b[i][k] = (p&gt;MIN_PROB) ? p : MIN_PROB;
    }
    <SPAN class="comment">/**
    @param i Row number of the symbol-generation matrix B
    @param k Column number of symbol-generation matrix B
    @param p Probability value
    @param bCheck If true, check the index bounds and the range of p
    @return true, if successful
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setB(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> k, <SPAN class="keyword">double</SPAN> p, <SPAN class="keyword">boolean</SPAN> bCheck) {
        <SPAN class="keyword">if</SPAN>((bCheck == <SPAN class="keyword">false</SPAN>) || 
            (i&gt;=0 &amp;&amp; i&lt;num_states &amp;&amp; k&gt;=0 &amp;&amp; k&lt;num_symbols &amp;&amp; p&lt;=1.0 &amp;&amp; p&gt;=0.0)) {
            setB(i,k,p);
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
        }
    }
    <SPAN class="comment">/**
    @param i Row number of the symbol-generation matrix B
    @param p Row vector of probability values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setB(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">double</SPAN>[] p) {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
            b[i][k] = (p[k]&gt;MIN_PROB) ? p[k] : MIN_PROB;
        }
    }
    <SPAN class="comment">/**
    @param i Row number of the symbol-generation matrix B
    @param p Row vector of probability values
    @param bNormalize If true, renormalize the row in case p is not normalized
    @return false, if B is unnormalized
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setB(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">double</SPAN>[] p, <SPAN class="keyword">boolean</SPAN> bNormalize) {
        setB(i,p);
        <SPAN class="keyword">if</SPAN>(bNormalize == <SPAN class="keyword">false</SPAN>) {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">try</SPAN> {
                normalizeRowB(i);
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
                <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
            }
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        }
    }
    <SPAN class="comment">/**
    @param p Matrix of probability values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setB(<SPAN class="keyword">double</SPAN>[][] p) {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
                b[i][k] = (p[i][k]&gt;MIN_PROB) ? p[i][k] : MIN_PROB;
            }
        }
    }
    <SPAN class="comment">/**
    @param p Matrix of probability values
    @param bNormalize If true, renormalize each row in case p is not normalized
    @return false, if B is unnormalized
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setB(<SPAN class="keyword">double</SPAN>[][] p, <SPAN class="keyword">boolean</SPAN> bNormalize) {
        setB(p);
        <SPAN class="keyword">if</SPAN>(bNormalize == <SPAN class="keyword">false</SPAN>) {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">try</SPAN> {
                normalizeRowB();
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
                <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
            }
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        }
    }
    
    <SPAN class="comment">/**
    Initialize the initial-state row vector Pi with random values.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setPi() {
        setPi(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Initialize the initial-state row vector Pi.
    @param bRandomize If true, initialize Pi with random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setPi(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">if</SPAN>(bRandomize == <SPAN class="keyword">true</SPAN>) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
                pi[j] = rand.nextDouble() + num_states*MIN_PROB;
            }    
            <SPAN class="keyword">try</SPAN> {
                normalizeRowPi();
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
            }
        }
        <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
                pi[j] = 1.0/num_states;
            }    
        }
    }
    <SPAN class="comment">/**
    @param j Column number of initial-state row vector Pi
    @param p Probability value
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setPi(<SPAN class="keyword">int</SPAN> j, <SPAN class="keyword">double</SPAN> p) {
        pi[j] = (p&gt;MIN_PROB) ? p : MIN_PROB;
    }
    <SPAN class="comment">/**
    @param j Column number of initial-state row vector Pi
    @param p Probability value
    @param bCheck If true, check the index bounds and the range of p
    @return true, if successful
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setPi(<SPAN class="keyword">int</SPAN> j, <SPAN class="keyword">double</SPAN> p, <SPAN class="keyword">boolean</SPAN> bCheck) {
        <SPAN class="keyword">if</SPAN>((bCheck == <SPAN class="keyword">false</SPAN>) || 
            (j&gt;=0 &amp;&amp; j&lt;num_states &amp;&amp; p&lt;=1.0 &amp;&amp; p&gt;=0.0)) {
            setPi(j,p);
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
        }
    }    
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setPi(<SPAN class="keyword">double</SPAN>[] p) {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
            pi[j] = (p[j]&gt;MIN_PROB) ? p[j] : MIN_PROB;
        }
    }    
    <SPAN class="comment">/**
    @param p Row vector of probability values
    @param bNormalize If true, renormalize Pi in case p is not normalized
    @return false, if Pi is unnormalized
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">boolean</SPAN> setPi(<SPAN class="keyword">double</SPAN>[] p, <SPAN class="keyword">boolean</SPAN> bNormalize) {
        setPi(p);
        <SPAN class="keyword">if</SPAN>(bNormalize == <SPAN class="keyword">false</SPAN>) {
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">try</SPAN> {
                normalizeRowB();
            } <SPAN class="keyword">catch</SPAN>(ProbabilityUnnormalizableException exc) {
                exc.printStackTrace();
                <SPAN class="keyword">return</SPAN> <SPAN class="keyword">false</SPAN>;
            }
            <SPAN class="keyword">return</SPAN> <SPAN class="keyword">true</SPAN>;
        }
    }
    
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @param j Column number of state-transition matrix A
    @return Probability value of A[i][j]
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> getA(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> j) {
        <SPAN class="keyword">return</SPAN> a[i][j];
    }
    <SPAN class="comment">/**
    @param i Row number of the state-transition matrix A
    @return Row vector of probability values of A[i][]
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN>[] getA(<SPAN class="keyword">int</SPAN> i) {
        <SPAN class="keyword">return</SPAN> a[i];
    }
    <SPAN class="comment">/**
    @return State-transition matrix A
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN>[][] getA() {
        <SPAN class="keyword">return</SPAN> a;
    }
    
    <SPAN class="comment">/**
    @param i Row number of the symbol-generation matrix B
    @param k Column number of symbol-generation matrix B
    @return Probability value of B[i][k]
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> getB(<SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> k) {
        <SPAN class="keyword">return</SPAN> b[i][k];
    }
    <SPAN class="comment">/**
    @param i Row number of the symbol-generation matrix B
    @return Row vector of probability value of B[i][]
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN>[] getB(<SPAN class="keyword">int</SPAN> i) {
        <SPAN class="keyword">return</SPAN> b[i];
    }
    <SPAN class="comment">/**
    @return Symbol-generation matrix B
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN>[][] getB() {
        <SPAN class="keyword">return</SPAN> b;
    }
    
    <SPAN class="comment">/**
    @param j Column number of inital-state row vector Pi
    @return Probability value of Pi[j]
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> getPi(<SPAN class="keyword">int</SPAN> j) {
        <SPAN class="keyword">return</SPAN> pi[j];
    }
    <SPAN class="comment">/**
    @return Inital-state row vector Pi
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN>[] getPi() {
        <SPAN class="keyword">return</SPAN> pi;
    }
    <SPAN class="comment">/**
    @param t Index of observation sequence
    @param j Column number of state vector Pi[t][] at time t
    @return Probability value of Pi[t][j]
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> getPi(<SPAN class="keyword">int</SPAN> t, <SPAN class="keyword">int</SPAN> j) {
        <SPAN class="keyword">if</SPAN>(t==0) {
            <SPAN class="keyword">return</SPAN> pi[j];
        } <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">double</SPAN> sum = 0.0;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                sum += getPi(t-1,i) * a[i][j];
            }
            <SPAN class="keyword">return</SPAN> sum;
        }    
    }

    <SPAN class="comment">/**
    Intialize probability matrices, A, B, and Pi, with random values.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setProbability() {
        setProbability(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Intialize probability matrices, A, B, and Pi.
    @param bRandomize If true, initialize probability matrices with random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setProbability(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        setA(bRandomize);
        setB(bRandomize);
        setPi(bRandomize);
    }
    
    <SPAN class="comment">/**
    Load model parameters from an XML file.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadModel(String file) {
        loadModel(file, <SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Load model parameters from a file.
    @param file Name of input file
    @param bXml If true, read file in XML format
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadModel(String file, <SPAN class="keyword">boolean</SPAN> bXml) {
        <SPAN class="keyword">if</SPAN>(bXml) {
            loadModelXml(file);
        } <SPAN class="keyword">else</SPAN> {
            loadModelAscii(file);
        }
    }
    <SPAN class="comment">/**
    Load model parameters from an Ascii file.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadModelAscii(String file) {
        <SPAN class="keyword">try</SPAN> {
            BufferedReader in =
                <SPAN class="keyword">new</SPAN> BufferedReader(
                    <SPAN class="keyword">new</SPAN> FileReader(file));
                    
            num_states = Integer.valueOf(in.readLine()).intValue();
            num_symbols = Integer.valueOf(in.readLine()).intValue();
            ll_bound = Integer.valueOf(in.readLine()).intValue();
            ur_bound = Integer.valueOf(in.readLine()).intValue();
            <SPAN class="comment">// check validaty of these parameters
</SPAN>
            a = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states][num_states];
            b = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states][num_symbols];
            pi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states];
            l_limit = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[num_states];
            r_limit = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[num_states];
            setLimits();

            StringTokenizer stkn = <SPAN class="keyword">null</SPAN>;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                stkn = <SPAN class="keyword">new</SPAN> StringTokenizer(in.readLine());
                <SPAN class="keyword">int</SPAN> j = 0;
                <SPAN class="keyword">while</SPAN>(stkn.hasMoreTokens()) {
                    a[i][j++] = Double.valueOf(stkn.nextToken()).doubleValue();
                }
            }    
            <SPAN class="comment">// check if j==num_states
</SPAN>            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                stkn = <SPAN class="keyword">new</SPAN> StringTokenizer(in.readLine());
                <SPAN class="keyword">int</SPAN> k = 0;
                <SPAN class="keyword">while</SPAN>(stkn.hasMoreTokens()) {
                    b[i][k++] = Double.valueOf(stkn.nextToken()).doubleValue();
                }
            }    
            <SPAN class="comment">// check if k==num_symbols
</SPAN>            stkn = <SPAN class="keyword">new</SPAN> StringTokenizer(in.readLine());
            <SPAN class="keyword">int</SPAN> j = 0;
            <SPAN class="keyword">while</SPAN>(stkn.hasMoreTokens()) {
                pi[j++] = Double.valueOf(stkn.nextToken()).doubleValue();
            }
            <SPAN class="comment">// check if j==num_states
</SPAN>            
             in.close();
        } <SPAN class="keyword">catch</SPAN>(FileNotFoundException exc) {
            System.out.println(<SPAN class="string">"File Not Found: "</SPAN> + file);
        } <SPAN class="keyword">catch</SPAN>(IOException exc) {
            exc.printStackTrace();
        }    
    }
    <SPAN class="comment">/**
    Load model parameters from an XML file.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadModelXml(String file) {

        <SPAN class="comment">// parse xml file!!!!
</SPAN>        DomParserFactory.setParser(SUN_PARSER);
        Document doc = DomParserFactory.openLocalDocument(file);

        NodeList nodeList = <SPAN class="keyword">null</SPAN>;
        NodeList childList = <SPAN class="keyword">null</SPAN>;
        Node childNode = <SPAN class="keyword">null</SPAN>;
        Element nodeElement = <SPAN class="keyword">null</SPAN>;
        Element childElement = <SPAN class="keyword">null</SPAN>;
        String strElement = <SPAN class="keyword">null</SPAN>;
 
        nodeList = doc.getElementsByTagName( <SPAN class="string">"states"</SPAN> );
        nodeElement = (Element) nodeList.item(0);
        strElement = nodeElement.getAttribute(<SPAN class="string">"count"</SPAN>);
        num_states = Integer.valueOf(strElement).intValue();
                    
        nodeList = doc.getElementsByTagName( <SPAN class="string">"symbols"</SPAN> );
        nodeElement = (Element) nodeList.item(0);
        strElement = nodeElement.getAttribute(<SPAN class="string">"count"</SPAN>);
        num_symbols = Integer.valueOf(strElement).intValue();
                                
        nodeList = doc.getElementsByTagName( <SPAN class="string">"bounds"</SPAN> );
        nodeElement = (Element) nodeList.item(0);
        strElement = nodeElement.getAttribute(<SPAN class="string">"ll_bound"</SPAN>);
        ll_bound = Integer.valueOf(strElement).intValue();
        nodeElement = (Element) nodeList.item(0);
        strElement = nodeElement.getAttribute(<SPAN class="string">"ur_bound"</SPAN>);
        ur_bound = Integer.valueOf(strElement).intValue();
        <SPAN class="comment">// check validaty of these parameters
</SPAN>
        a = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states][num_states];
        b = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states][num_symbols];
        pi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[num_states];
        l_limit = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[num_states];
        r_limit = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[num_states];
        setLimits();

        nodeList = doc.getElementsByTagName( <SPAN class="string">"transition_matrix"</SPAN> );
        childList = nodeList.item(0).getChildNodes(); <SPAN class="comment">// "element"
</SPAN>        <SPAN class="keyword">for</SPAN> (<SPAN class="keyword">int</SPAN> m = 0 ; m &lt; childList.getLength() ; m++ ){
	          childNode = childList.item(m);
	          <SPAN class="keyword">if</SPAN>(childNode.getNodeType() == Node.ELEMENT_NODE ){
		            childElement = (Element) childNode;
	          } <SPAN class="keyword">else</SPAN> {
		            <SPAN class="keyword">continue</SPAN>;
	          }
            String row = childElement.getAttribute(<SPAN class="string">"row"</SPAN>);
            String col = childElement.getAttribute(<SPAN class="string">"col"</SPAN>);
            String value = childElement.getAttribute(<SPAN class="string">"value"</SPAN>);
            <SPAN class="keyword">if</SPAN>( row != <SPAN class="keyword">null</SPAN> &amp;&amp; col != <SPAN class="keyword">null</SPAN> ){
                <SPAN class="keyword">int</SPAN> i = Integer.valueOf(row).intValue();
                <SPAN class="keyword">int</SPAN> j = Integer.valueOf(col).intValue();
                a[i][j] = Double.valueOf(value).doubleValue();
            }
        }

        nodeList = doc.getElementsByTagName( <SPAN class="string">"symbol_generation_matrix"</SPAN> );
        childList = nodeList.item(0).getChildNodes(); <SPAN class="comment">// "element"
</SPAN>        <SPAN class="keyword">for</SPAN> (<SPAN class="keyword">int</SPAN> m = 0 ; m &lt; childList.getLength() ; m++ ){
	         childNode = childList.item(m);
	         <SPAN class="keyword">if</SPAN>(childNode.getNodeType() == Node.ELEMENT_NODE ){
		           childElement = (Element) childNode;
	         } <SPAN class="keyword">else</SPAN> {
		           <SPAN class="keyword">continue</SPAN>;
	         }
            String row = childElement.getAttribute(<SPAN class="string">"row"</SPAN>);
            String col = childElement.getAttribute(<SPAN class="string">"col"</SPAN>);
            String value = childElement.getAttribute(<SPAN class="string">"value"</SPAN>);
            <SPAN class="keyword">if</SPAN>( row != <SPAN class="keyword">null</SPAN> &amp;&amp; col != <SPAN class="keyword">null</SPAN> ){
                <SPAN class="keyword">int</SPAN> i = Integer.valueOf(row).intValue();
                <SPAN class="keyword">int</SPAN> k = Integer.valueOf(col).intValue();
                b[i][k] = Double.valueOf(value).doubleValue();
            }
        }

        nodeList = doc.getElementsByTagName( <SPAN class="string">"initial_state_vector"</SPAN> );
        childList = nodeList.item(0).getChildNodes(); <SPAN class="comment">// "element"
</SPAN>        <SPAN class="keyword">for</SPAN> (<SPAN class="keyword">int</SPAN> m = 0 ; m &lt; childList.getLength() ; m++ ){
	          childNode = childList.item(m);
	          <SPAN class="keyword">if</SPAN>(childNode.getNodeType() == Node.ELEMENT_NODE ){
		            childElement = (Element) childNode;
	          } <SPAN class="keyword">else</SPAN> {
		            <SPAN class="keyword">continue</SPAN>;
	          }
            String row = childElement.getAttribute(<SPAN class="string">"row"</SPAN>);
            String value = childElement.getAttribute(<SPAN class="string">"value"</SPAN>);
            <SPAN class="keyword">if</SPAN>( row != <SPAN class="keyword">null</SPAN>){
                <SPAN class="keyword">int</SPAN> j = Integer.valueOf(row).intValue();
                pi[j] = Double.valueOf(value).doubleValue();
            }
        }

    }
    <SPAN class="comment">/**
    Save model parameters to a given file in XML format.
    @param file Name of output file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> saveModel(String file) {
        saveModel(file, <SPAN class="keyword">true</SPAN>);
    }    
    <SPAN class="comment">/**
    Save model parameters to a given file.
    @param file Name of output file
    @param bXml If true, save model in XML format
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> saveModel(String file, <SPAN class="keyword">boolean</SPAN> bXml) {
        <SPAN class="keyword">if</SPAN>(bXml) {
            saveModelXml(file);
        } <SPAN class="keyword">else</SPAN> {
            saveModelAscii(file);
        }
    }    
    <SPAN class="comment">/**
    Save model parameters to a given file in Ascii format.
    @param file Name of output file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> saveModelAscii(String file) {
        <SPAN class="keyword">try</SPAN> {
            PrintWriter out =
                <SPAN class="keyword">new</SPAN> PrintWriter(
                    <SPAN class="keyword">new</SPAN> BufferedWriter(
                        <SPAN class="keyword">new</SPAN> FileWriter(file)));
                        
            out.println(num_states);
            out.println(num_symbols);
            out.println(ll_bound);
            out.println(ur_bound);

            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
                    out.print(a[i][j]);
                    out.print(<SPAN class="string">"\t"</SPAN>);
                }
                out.println();
            }    
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
                    out.print(b[i][k]);
                    out.print(<SPAN class="string">"\t"</SPAN>);
                }
                out.println();
            }    
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
                out.print(pi[j]);
                out.print(<SPAN class="string">"\t"</SPAN>);
            }
            out.println();
            
            <SPAN class="comment">//
</SPAN>            <SPAN class="comment">//out.flush();
</SPAN>            out.close();
        } <SPAN class="keyword">catch</SPAN>(FileNotFoundException exc) {
            System.out.println(<SPAN class="string">"File Not Found: "</SPAN> + file);
        } <SPAN class="keyword">catch</SPAN>(IOException exc) {
            exc.printStackTrace();
        }
    }
    <SPAN class="comment">/**
    Save model parameters to a given file in XML format.
    @param file Name of output file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> saveModelXml(String file) {
        <SPAN class="keyword">try</SPAN> {
            PrintWriter out =
                <SPAN class="keyword">new</SPAN> PrintWriter(
                    <SPAN class="keyword">new</SPAN> BufferedWriter(
                        <SPAN class="keyword">new</SPAN> FileWriter(file)));
            
            out.println(<SPAN class="string">"&lt;?xml version=\"1.0\"?&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;!DOCTYPE hmm SYSTEM \"hmm03.dtd\"&gt;"</SPAN>);
            out.println(<SPAN class="string">" "</SPAN>);
            out.println(<SPAN class="string">"&lt;hmm version=\"0.3\"&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;name&gt;"</SPAN>);
            out.println(<SPAN class="string">"Hidden Markov Model Test"</SPAN>);
            out.println(<SPAN class="string">"&lt;/name&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;model&gt;"</SPAN>);
            out.print(<SPAN class="string">"&lt;states count=\""</SPAN>);
            out.print(num_states);
            out.println(<SPAN class="string">"\"&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;/states&gt;"</SPAN>);
            out.print(<SPAN class="string">"&lt;symbols count=\""</SPAN>);
            out.print(num_symbols);
            out.println(<SPAN class="string">"\"&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;/symbols&gt;"</SPAN>);
            out.print(<SPAN class="string">"&lt;bounds ll_bound=\""</SPAN>);
            out.print(ll_bound);
            out.print(<SPAN class="string">"\" ur_bound=\""</SPAN>);
            out.print(ur_bound);
            out.println(<SPAN class="string">"\"&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;/bounds&gt;"</SPAN>);

            out.println(<SPAN class="string">"&lt;transition_matrix&gt;"</SPAN>);
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
                    out.print(<SPAN class="string">"&lt;element row=\""</SPAN> + i + <SPAN class="string">"\" "</SPAN> + <SPAN class="string">"col=\""</SPAN> + j + <SPAN class="string">"\" "</SPAN>
                              + <SPAN class="string">"value=\""</SPAN> + a[i][j] + <SPAN class="string">"\"/&gt;"</SPAN>); 
                }
                out.println();
            }    
            out.println(<SPAN class="string">"&lt;/transition_matrix&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;symbol_generation_matrix&gt;"</SPAN>);
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;num_states;i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;num_symbols;k++) {
                    out.print(<SPAN class="string">"&lt;element row=\""</SPAN> + i + <SPAN class="string">"\" "</SPAN> + <SPAN class="string">"col=\""</SPAN> + k + <SPAN class="string">"\" "</SPAN>
                              + <SPAN class="string">"value=\""</SPAN> + b[i][k] + <SPAN class="string">"\"/&gt;"</SPAN>); 
                }
                out.println();
            }    
            out.println(<SPAN class="string">"&lt;/symbol_generation_matrix&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;initial_state_vector&gt;"</SPAN>);
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;num_states;j++) {
                out.print(<SPAN class="string">"&lt;element row=\""</SPAN> + j + <SPAN class="string">"\" "</SPAN>
                          + <SPAN class="string">"value=\""</SPAN> + pi[j] + <SPAN class="string">"\"/&gt;"</SPAN>); 
            }
            out.println();
            out.println(<SPAN class="string">"&lt;/initial_state_vector&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;/model&gt;"</SPAN>);
            out.println(<SPAN class="string">"&lt;/hmm&gt;"</SPAN>);

            <SPAN class="comment">//
</SPAN>            <SPAN class="comment">//out.flush();
</SPAN>            out.close();
        } <SPAN class="keyword">catch</SPAN>(FileNotFoundException exc) {
            System.out.println(<SPAN class="string">"File Not Found: "</SPAN> + file);
        } <SPAN class="keyword">catch</SPAN>(IOException exc) {
            exc.printStackTrace();
        }
    }
    <SPAN class="comment">//&lt;/Public_Methods&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Main_Method&gt;
</SPAN>    <SPAN class="comment">/**
    This function is provided for testing purposes.
    Direct modification of this class is not recommended
    unless there is a bug. (In which case please notify me.)
    Please use inheritance or aggregation (composition).
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">void</SPAN> main(String[] args) {
        Model node = <SPAN class="keyword">new</SPAN> Model(4, 5, 0, 1, <SPAN class="keyword">false</SPAN>);
        node.setProbability(<SPAN class="keyword">true</SPAN>);
        
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;node.num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;node.num_states;j++) {
                System.out.print(node.getA(i,j) + <SPAN class="string">"\t"</SPAN>);
            }
            System.out.println();
        }
        System.out.println();
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;node.num_states;j++) {
            System.out.print(node.getPi(j) + <SPAN class="string">"\t"</SPAN>);
        }
        System.out.println();
        System.out.println();
        <SPAN class="comment">/*
        for(int i=0;i&lt;node.num_states;i++) {
            for(int k=0;k&lt;node.num_symbols;k++) {
                System.out.print(node.getB(i,k) + "\t");
            }
            System.out.println();
        }
        */</SPAN>
        
        <SPAN class="keyword">try</SPAN> {
            ObjectOutputStream out =
                <SPAN class="keyword">new</SPAN> ObjectOutputStream(
                    <SPAN class="keyword">new</SPAN> FileOutputStream(<SPAN class="string">"model.hmm"</SPAN>));
            out.writeObject(node);
            out.close();
        } <SPAN class="keyword">catch</SPAN>(Exception exc) {
            exc.printStackTrace();
        }
        
        Model newNode = <SPAN class="keyword">null</SPAN>;
        <SPAN class="keyword">try</SPAN> {
            ObjectInputStream in =
                <SPAN class="keyword">new</SPAN> ObjectInputStream(
                    <SPAN class="keyword">new</SPAN> FileInputStream(<SPAN class="string">"model.hmm"</SPAN>));
            newNode = (Model) in.readObject();
            in.close();
        } <SPAN class="keyword">catch</SPAN>(Exception exc) {
            exc.printStackTrace();
        }
        
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;newNode.num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;newNode.num_states;j++) {
                System.out.print(newNode.getA(i,j) + <SPAN class="string">"\t"</SPAN>);
            }
            System.out.println();
        }
        System.out.println();
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;newNode.num_states;j++) {
            System.out.print(newNode.getPi(j) + <SPAN class="string">"\t"</SPAN>);
        }
        System.out.println();
        System.out.println();
        <SPAN class="comment">/*
        for(int i=0;i&lt;newNode.num_states;i++) {
            for(int k=0;k&lt;newNode.num_symbols;k++) {
                System.out.print(newNode.getB(i,k) + "\t");
            }
            System.out.println();
        }
        */</SPAN>
        
        newNode.saveModel(<SPAN class="string">"test.xml"</SPAN>, <SPAN class="keyword">true</SPAN>);
        newNode.loadModel(<SPAN class="string">"test.xml"</SPAN>, <SPAN class="keyword">true</SPAN>);
        
        <SPAN class="comment">//
</SPAN>        <SPAN class="comment">//newNode = new Model("model.xml", true);
</SPAN>        
        System.out.println(newNode.num_states);
        System.out.println(newNode.num_symbols);
        System.out.println(newNode.ll_bound);
        System.out.println(newNode.ur_bound);
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;newNode.num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> jj=0;jj&lt;newNode.num_states;jj++) {
                System.out.print(newNode.a[i][jj]);
                System.out.print(<SPAN class="string">"\t"</SPAN>);
            }
            System.out.println();
        }    
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;newNode.num_states;i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;newNode.num_symbols;k++) {
                System.out.print(newNode.b[i][k]);
                System.out.print(<SPAN class="string">"\t"</SPAN>);
            }
            System.out.println();
        }    
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> jjj=0;jjj&lt;newNode.num_states;jjj++) {
            System.out.print(newNode.pi[jjj]);
            System.out.print(<SPAN class="string">"\t"</SPAN>);
        }
        System.out.println();
    }
    <SPAN class="comment">//&lt;/Main_Method&gt;
</SPAN>}
</PRE>
</BODY></HTML>
