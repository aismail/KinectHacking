<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML lang="en"><HEAD>
<META http-equiv="Generator" content="com.bluecraft.htmlize">
<TITLE>Source Code: Hmm.java</TITLE>
<STYLE>
body {
    background: ivory;
    color: black;
}
DIV.description {
    color: maroon;
    margin-top: -0.4cm;
}
SPAN.linenumber {
    color: maroon;
}
SPAN.string {
    color: red;
}
SPAN.comment {
    color: green;
}
SPAN.keyword {
    color: blue;
}
SPAN.userkeyword {
    color: purple;
    font-weight: bold;
}
</STYLE>
</HEAD><BODY>
<H2>Hmm.java</H2>
<DIV class="description">
Generated by <STRONG>com.bluecraft.htmlize</STRONG> HTML-ization Utility Classes.
</DIV>
<PRE>
<SPAN class="comment">//////////////////////////////////////////////////////////////////////////
</SPAN><SPAN class="comment">// The contents of this file are subject to the Mozilla Public License
</SPAN><SPAN class="comment">// Version 1.0 (the "License"); you may not use this file except in
</SPAN><SPAN class="comment">// compliance with the License. You may obtain a copy of the License at
</SPAN><SPAN class="comment">// http://www.mozilla.org/MPL/
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// Software distributed under the License is distributed on an "AS IS"
</SPAN><SPAN class="comment">// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
</SPAN><SPAN class="comment">// License for the specific language governing rights and limitations under
</SPAN><SPAN class="comment">// the License.
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// The Original Code is Hidden Markov Model Library in Java.
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// The Initial Developer of the Original Code is Hyoungsoo Yoon.
</SPAN><SPAN class="comment">// Portions created by Hyoungsoo Yoon are
</SPAN><SPAN class="comment">// Copyright (C) 1999 Hyoungsoo Yoon.  All Rights Reserved.
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">// Contributor(s):
</SPAN><SPAN class="comment">//
</SPAN><SPAN class="comment">//////////////////////////////////////////////////////////////////////////
</SPAN>

<SPAN class="comment">/*
Hidden Markov Model Library in Java.
Please refer to Rabiner 1989.
All algorithms are directly taken from this article.
Notations and variable names also closely follow the conventions used in this paper.

@copyright  Hyoungsoo Yoon
@date  Feb 21st, 1999
*/</SPAN>

<SPAN class="keyword">package</SPAN> com.bluecraft.hmm;


<SPAN class="keyword">import</SPAN> java.util.*;
<SPAN class="keyword">import</SPAN> java.io.*;

<SPAN class="comment">/**
Hidden Markov model.
This class adds a sequence of observed symbols to the class Model.
Please refer to Rabiner 1989.

@author  Hyoungsoo Yoon
@version  0.3
*/</SPAN>
<SPAN class="keyword">public</SPAN> <SPAN class="keyword">class</SPAN> Hmm <SPAN class="keyword">implements</SPAN> Serializable {

    <SPAN class="comment">//&lt;Static_Fields&gt;
</SPAN>    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">final</SPAN> <SPAN class="keyword">int</SPAN> MAX_ITERATION = 100;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">final</SPAN> <SPAN class="keyword">double</SPAN> MIN_ERROR = 0.001;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">final</SPAN> <SPAN class="keyword">int</SPAN> MAX_LEN_OBSEQ = 10;

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">static</SPAN> Random rand = <SPAN class="keyword">new</SPAN> Random();
    <SPAN class="comment">//&lt;/Static_Fields&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Private_Fields&gt;
</SPAN>    <SPAN class="comment">/**
    @serial  Underlying Markov model and its parameters (A, B, and pi)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> Model lambda;
    <SPAN class="comment">/**
    @serial  Forward variables  (Rabiner eq. 18)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[][] alpha;
    <SPAN class="comment">/**
    @serial  Backward variables  (Rabiner eq. 23)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[][] beta;
    <SPAN class="comment">/**
    @serial  Internal state probabilities (Rabiner eq. 26)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[][] gamma;
    <SPAN class="comment">/**
    @serial  Internal pair-state probabilities (Rabiner eq. 36)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[][][] ksi;
    <SPAN class="comment">/**
    @serial  Best score variables (Rabiner eq. 30)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[][] delta;
    <SPAN class="comment">/**
    @serial  Backtracking variables (Rabiner eq. 33b)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">int</SPAN>[][] psi;
    <SPAN class="comment">/**
    @serial  Most likely path (Rabiner eq. 35)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">int</SPAN>[] qstar;
    <SPAN class="comment">/**
    @serial  Scale factor (Rabiner eq. 91)
    */</SPAN>
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN>[] scaleFactor;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">transient</SPAN> <SPAN class="keyword">int</SPAN>  len_obseq = 0;
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">transient</SPAN> <SPAN class="keyword">int</SPAN>[] obSeq;
    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">transient</SPAN> String file_name = <SPAN class="keyword">null</SPAN>;  <SPAN class="comment">// saves to and loads from this file
</SPAN>    <SPAN class="comment">//&lt;/Private_Fields&gt;
</SPAN>

    <SPAN class="comment">//&lt;Protectd_Fields&gt;
</SPAN>    <SPAN class="comment">//&lt;/Protectd_Fields&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Public_Fields&gt;
</SPAN>    <SPAN class="comment">//&lt;/Public_Fields&gt;
</SPAN>

    <SPAN class="comment">//&lt;Constructors&gt;
</SPAN>    <SPAN class="comment">/**
    Construct HMM with a minimum size (length of observation sequence: 1).
    The elements of the matrices are initialized by random values.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm() {
        <SPAN class="keyword">this</SPAN>(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Construct HMM with a minimum size (length of observation sequence: 1).
    @param bRandomize If true, the elements of the matrices are initialized by random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">this</SPAN>(1, bRandomize);
    }
    <SPAN class="comment">/**
    Construct HMM by specifying its length (number of states: 1, number of symbols: 1).
    The elements of the matrices are initialized by random values.
    @param lobseq Length of symbols observation sequence
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(<SPAN class="keyword">int</SPAN> lobseq) {
        <SPAN class="keyword">this</SPAN>(lobseq, <SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Construct HMM by specifying its length (number of states: 1, number of symbols: 1).
    @param lobseq Length of symbols observation sequence
    @param bRandomize If true, the elements of the matrices are initialized by random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(<SPAN class="keyword">int</SPAN> lobseq, <SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">this</SPAN>(lobseq, 1, 1, 0, 0, bRandomize);
    }
    <SPAN class="comment">/**
    Construct HMM by specifying its length, number of states, and number of symbols.
    The elements of the matrices are initialized by random values.
    @param lobseq Length of symbols observation sequence
    @param nstates Number of states
    @param nsymbols Number of symbols
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(<SPAN class="keyword">int</SPAN> lobseq, <SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols) {
        <SPAN class="keyword">this</SPAN>(lobseq, nstates, nsymbols, <SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Construct HMM by specifying its length, number of states, and number of symbols.
    @param lobseq Length of symbols observation sequence
    @param nstates Number of states
    @param nsymbols Number of symbols
    @param bRandomize If true, the elements of the matrices are initialized by random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(<SPAN class="keyword">int</SPAN> lobseq, <SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols, <SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">this</SPAN>(lobseq, nstates, nsymbols, nstates-1, nstates-1, bRandomize);
    }
    <SPAN class="comment">/**
    Construct HMM by specifying its length, number of states, and number of symbols.
    Upper bound and lower bound along the diagonal direction are also specified, outside which all probability elements are identically zero.
    The elements of the matrices are initialized by random values.
    @param lobseq Length of symbols observation sequence
    @param nstates Number of states
    @param nsymbols Number of symbols
    @param llb Lower bound below which all probability elements are identically zero.
    @param urb Upper bound beyond which all probability elements are identically zero.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(<SPAN class="keyword">int</SPAN> lobseq, <SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols, <SPAN class="keyword">int</SPAN> llb, <SPAN class="keyword">int</SPAN> urb) {
        <SPAN class="keyword">this</SPAN>(lobseq, nstates, nsymbols, llb, urb, <SPAN class="keyword">true</SPAN>);
    }    
    <SPAN class="comment">/**
    Construct HMM by specifying its length, number of states, and number of symbols.
    Upper bound and lower bound along the diagonal direction are also specified, outside which all probability elements are identically zero.
    @param lobseq Length of symbols observation sequence
    @param nstates Number of states
    @param nsymbols Number of symbols
    @param llb Lower bound below which all probability elements are identically zero.
    @param urb Upper bound beyond which all probability elements are identically zero.
    @param bRandomize If true, the elements of the matrices are initialized by random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(<SPAN class="keyword">int</SPAN> lobseq, <SPAN class="keyword">int</SPAN> nstates, <SPAN class="keyword">int</SPAN> nsymbols, <SPAN class="keyword">int</SPAN> llb, <SPAN class="keyword">int</SPAN> urb, <SPAN class="keyword">boolean</SPAN> bRandomize) {
        lambda = <SPAN class="keyword">new</SPAN> Model(nstates, nsymbols, llb, urb, bRandomize);
    
        len_obseq = lobseq;
        
        alpha = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        beta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        gamma = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        ksi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq-1][getNumStates()][getNumStates()];
        delta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        psi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq][getNumStates()];
        qstar = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
        scaleFactor = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq];
        obSeq = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
        
        initializeModel(bRandomize);
    }
    <SPAN class="comment">/**
    Construct HMM by loading model parameters from an XML file.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(String file) {
        <SPAN class="keyword">this</SPAN>(file, 1, <SPAN class="keyword">true</SPAN>);
    }    
    <SPAN class="comment">/**
    Construct HMM by loading model parameters from an XML file.
    @param file Name of input file
    @param lobseq Length of observation sequence
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(String file, <SPAN class="keyword">int</SPAN> lobseq) {
        <SPAN class="keyword">this</SPAN>(file, lobseq, <SPAN class="keyword">true</SPAN>);
    }    
    <SPAN class="comment">/**
    Construct HMM by loading model parameters from a file.
    @param file Name of input file
    @param bXml If true, read input file in XML format
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(String file, <SPAN class="keyword">boolean</SPAN> bXml) {
        <SPAN class="keyword">this</SPAN>(file, 1, bXml);
    }    
    <SPAN class="comment">/**
    Construct HMM by loading model parameters from a file.
    @param file Name of input file
    @param lobseq Length of observation sequence
    @param bXml If true, read input file in XML format
    */</SPAN>
    <SPAN class="keyword">public</SPAN> Hmm(String file, <SPAN class="keyword">int</SPAN> lobseq, <SPAN class="keyword">boolean</SPAN> bXml) {
        lambda = <SPAN class="keyword">new</SPAN> Model(file, bXml);
        len_obseq = lobseq;
        
        alpha = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        beta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        gamma = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        ksi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq-1][getNumStates()][getNumStates()];
        delta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        psi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq][getNumStates()];
        qstar = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
        scaleFactor = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq];
        obSeq = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
   }    
    <SPAN class="comment">//&lt;/Constructors&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Private_Methods&gt;
</SPAN>    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> computeScaleFactor() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            computeScaleFactor(t);
        }    
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> computeScaleFactor(<SPAN class="keyword">int</SPAN> t) {
        scaleFactor[t] = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
            scaleFactor[t] += alpha[t][i];
        }    
    }
    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleAlpha() {
        rescaleAlpha(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleAlpha(<SPAN class="keyword">boolean</SPAN> bNewScale) {
        <SPAN class="keyword">if</SPAN>(bNewScale) {
            computeScaleFactor();
        }
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            rescaleAlpha(t);
        }    
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleAlpha(<SPAN class="keyword">int</SPAN> t) {
        rescaleAlpha(t,<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleAlpha(<SPAN class="keyword">int</SPAN> t, <SPAN class="keyword">boolean</SPAN> bNewScale) {
        <SPAN class="keyword">if</SPAN>(bNewScale) {
            computeScaleFactor(t);
        }
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
            alpha[t][i] /= scaleFactor[t];
        }    
    }
    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleBeta() {
        rescaleBeta(<SPAN class="keyword">false</SPAN>);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleBeta(<SPAN class="keyword">boolean</SPAN> bNewScale) {
        <SPAN class="keyword">if</SPAN>(bNewScale) {
            computeScaleFactor();
        }
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            rescaleBeta(t);
        }    
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleBeta(<SPAN class="keyword">int</SPAN> t) {
        rescaleBeta(t,<SPAN class="keyword">false</SPAN>);
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleBeta(<SPAN class="keyword">int</SPAN> t, <SPAN class="keyword">boolean</SPAN> bNewScale) {
        <SPAN class="keyword">if</SPAN>(bNewScale) {
            computeScaleFactor(t);
        }
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
            beta[t][i] /= scaleFactor[t];
        }    
    }
    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleTrellis() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            rescaleTrellis(t);
        }    
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> rescaleTrellis(<SPAN class="keyword">int</SPAN> t) {
        rescaleAlpha(t,<SPAN class="keyword">true</SPAN>);
        rescaleBeta(t,<SPAN class="keyword">false</SPAN>);
    }
    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> clearAlpha() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                alpha[t][i] = 0.0;
            }
        }    
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> clearBeta() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                beta[t][i] = 0.0;
            }
        }    
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> clearGamma() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                gamma[t][i] = 0.0;
            }
        }    
    }
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> clearTrellis() {
        clearAlpha();
        clearBeta();
        clearGamma();
    }

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN> forwardAlpha() {
        clearAlpha();
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;getNumStates();j++) {
            alpha[0][j] = lambda.getPi(j) * lambda.getB(j,obSeq[0]);
        }    
        rescaleAlpha(0);

        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=1;t&lt;len_obseq;t++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                <SPAN class="keyword">double</SPAN> sum = 0.0;
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=lambda.getLLimit(i);j&lt;=lambda.getRLimit(i);j++) {
                    sum += alpha[t-1][i] * lambda.getA(i,j);
                }
                alpha[t][i] = sum*lambda.getB(i,obSeq[t]);
            }
            rescaleAlpha(t);
        }    
        <SPAN class="keyword">double</SPAN> sum = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
            sum += alpha[len_obseq-1][i];
        }    
        <SPAN class="keyword">return</SPAN> sum;
    }    
            
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> backwardBeta() {
        clearBeta();
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;getNumStates();j++) {
            beta[len_obseq-1][j] = 1.0;
        }    
        rescaleBeta(len_obseq-1);

        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=len_obseq-2;t&gt;=0;t--) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                <SPAN class="keyword">double</SPAN> sum = 0.0;
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=lambda.getLLimit(i);j&lt;=lambda.getRLimit(i);j++) {
                    sum += beta[t+1][i] * lambda.getA(i,j) * lambda.getB(j,obSeq[t+1]);
                }
                beta[t][i] = sum;
            }
            rescaleBeta(t);
        }    
    }    
    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> computeGamma() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            <SPAN class="keyword">double</SPAN> sum = 0.0;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                gamma[t][i] = alpha[t][i] * beta[t][i];
                sum += gamma[t][i];
            }
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                gamma[t][i] /= sum;
            }
        }    
    }    

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN> computeDelta(<SPAN class="keyword">int</SPAN> t, <SPAN class="keyword">int</SPAN> j) {
        <SPAN class="keyword">if</SPAN>(t==0) {
            psi[t][j] = 0;
            <SPAN class="keyword">return</SPAN> delta[t][j] = lambda.getPi(j) * lambda.getB(j,obSeq[t]);
        }
        <SPAN class="keyword">else</SPAN> <SPAN class="keyword">if</SPAN>(t==len_obseq) {
            <SPAN class="keyword">double</SPAN> max = 0.0;
            <SPAN class="keyword">double</SPAN> tmp;
            <SPAN class="keyword">int</SPAN> indx = 0;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                tmp = computeDelta(t-1,i);
                <SPAN class="keyword">if</SPAN>(tmp &gt;= max) {
                    max = tmp;
                    indx = i;
                }
            }
            qstar[t-1] = indx;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> s=t-2;s&gt;=0;s--) {
                qstar[s] = psi[s+1][qstar[s+1]];
            }    
            <SPAN class="keyword">return</SPAN> max;
        }
        <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">double</SPAN> max = 0.0;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                <SPAN class="keyword">double</SPAN> tmp = computeDelta(t-1,i) * lambda.getA(i,j) * lambda.getB(j,obSeq[t]);
                <SPAN class="keyword">if</SPAN>(tmp &gt;= max) {
                    max = tmp;
                }
            }
            <SPAN class="keyword">double</SPAN> amax = 0.0;
            <SPAN class="keyword">int</SPAN> indx = 0;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                <SPAN class="keyword">double</SPAN> atmp = computeDelta(t-1,i) * lambda.getA(i,j);
                <SPAN class="keyword">if</SPAN>(atmp &gt;= amax) {
                    amax = atmp;
                    indx = i;
                }
            }
            psi[t][j] = indx;
            <SPAN class="keyword">return</SPAN> delta[t][j] = max;
        }    
    }

    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> viterbiAlgorithm() {
        <SPAN class="keyword">return</SPAN> computeDelta(len_obseq,0); <SPAN class="comment">// 0 arbitrary
</SPAN>    }    

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> computeKsi() {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq-1;t++) {
            <SPAN class="keyword">double</SPAN> sum = 0.0;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=lambda.getLLimit(i);j&lt;=lambda.getRLimit(i);j++) {
                    ksi[t][i][j] = alpha[t][i] * beta[t+1][i] * lambda.getA(i,j) * lambda.getB(j,obSeq[t+1]);
                    sum += ksi[t][i][j];
                }    
            }
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=lambda.getLLimit(i);j&lt;=lambda.getRLimit(i);j++) {
                    ksi[t][i][j] /= sum;
                }    
            }
        }    
    }    
    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN> forwardBackwardTrellis() {
        <SPAN class="keyword">double</SPAN> ret = forwardAlpha();
        backwardBeta();
        computeGamma();
        computeKsi();
        <SPAN class="keyword">return</SPAN> ret;
    }

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN> sumGamma(<SPAN class="keyword">int</SPAN> t, <SPAN class="keyword">int</SPAN> i) {
        <SPAN class="keyword">double</SPAN> sum = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> s=0;s&lt;t;s++) {
            sum += gamma[s][i];
        }
        <SPAN class="keyword">return</SPAN> sum;
    }    
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN> sumGamma(<SPAN class="keyword">int</SPAN> t, <SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> k) {
        <SPAN class="keyword">double</SPAN> sum = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> s=0;s&lt;t;s++) {
            <SPAN class="keyword">if</SPAN>(obSeq[s] == k) {
                sum += gamma[s][i];
            }    
        }
        <SPAN class="keyword">return</SPAN> sum;
    }    
                
    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">double</SPAN> sumKsi(<SPAN class="keyword">int</SPAN> t, <SPAN class="keyword">int</SPAN> i, <SPAN class="keyword">int</SPAN> j) {
        <SPAN class="keyword">double</SPAN> sum = 0.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> s=0;s&lt;t;s++) {
            sum += ksi[s][i][j];
        }
        <SPAN class="keyword">return</SPAN> sum;
    }    

    <SPAN class="keyword">private</SPAN> <SPAN class="keyword">void</SPAN> reestimateLambda() {
        <SPAN class="comment">// (1) pi
</SPAN>        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
            lambda.setPi(i,gamma[0][i]);
        }
        
        <SPAN class="comment">// (2) a
</SPAN>        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
            <SPAN class="keyword">double</SPAN> a_denom = sumGamma(len_obseq-1,i);
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=lambda.getLLimit(i);j&lt;=lambda.getRLimit(i);j++) {
                <SPAN class="keyword">double</SPAN> a_numer = sumKsi(len_obseq-1,i,j);
                lambda.setA(i,j,a_numer/a_denom);
            }
        }
        
        <SPAN class="comment">// (3) b
</SPAN>        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
            <SPAN class="keyword">double</SPAN> b_denom = sumGamma(len_obseq,i);
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;getNumSymbols();k++) {
                <SPAN class="keyword">double</SPAN> b_numer = sumGamma(len_obseq,i,k);
                lambda.setB(i,k,b_numer/b_denom);
            }
        }
    }
    <SPAN class="comment">//&lt;/Private_Methods&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Protected_Methods&gt;
</SPAN>    <SPAN class="comment">//&lt;/Protected_Methods&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Public_Methods&gt;
</SPAN>    <SPAN class="comment">/**
    Retrieves the number of internal states.
    @return  Number of internal states of the underlying model.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getNumStates() {
        <SPAN class="keyword">return</SPAN> lambda.getNumStates();
    }
    <SPAN class="comment">/**
    Retrieves the number of observation symbols.
    @return  Number of observation symbols.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getNumSymbols() {
        <SPAN class="keyword">return</SPAN> lambda.getNumSymbols();
    }
    <SPAN class="comment">/**
    Retrieves the length of the observation sequence.
    @return  Length of the observation sequence.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getLenObSeq() {
        <SPAN class="keyword">return</SPAN> len_obseq;
    }

    <SPAN class="comment">/**
    Load model parameters from an XML file.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmm(String file) {
        loadHmm(file, 1, <SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Load model parameters from an XML file.
    @param file Name of input file
    @param bXml If true, read file in XML format
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmm(String file, <SPAN class="keyword">boolean</SPAN> bXml) {
        loadHmm(file, 1, bXml);
    }
    <SPAN class="comment">/**
    Load model parameters from a file.
    @param file Name of input file
    @param lobseq Length of observation sequence
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmm(String file, <SPAN class="keyword">int</SPAN> lobseq) {
        loadHmm(file, lobseq, <SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Load model parameters from a file.
    @param file Name of input file
    @param lobseq Length of observation sequence
    @param bXml If true, read file in XML format
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmm(String file, <SPAN class="keyword">int</SPAN> lobseq, <SPAN class="keyword">boolean</SPAN> bXml) {
        <SPAN class="keyword">if</SPAN>(bXml) {
            loadHmmXml(file, lobseq);
        } <SPAN class="keyword">else</SPAN> {
            loadHmmAscii(file, lobseq);
        }
    }
    <SPAN class="comment">/**
    Load model parameters from an Ascii file.
    Length of observation sequence is set to 1.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmmAscii(String file) {
        loadHmmAscii(file, 1);
    }
    <SPAN class="comment">/**
    Load model parameters from an Ascii file.
    @param file Name of input file
    @param lobseq Length of observation sequence
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmmAscii(String file, <SPAN class="keyword">int</SPAN> lobseq) {
        lambda.loadModelAscii(file);
        len_obseq = lobseq;
        
        alpha = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        beta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        gamma = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        ksi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq-1][getNumStates()][getNumStates()];
        delta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        psi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq][getNumStates()];
        qstar = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
        scaleFactor = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq];
        obSeq = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
    }
    <SPAN class="comment">/**
    Load model parameters from an Xml file.
    Length of observation sequence is set to 1.
    @param file Name of input file
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmmXml(String file) {
        loadHmmXml(file, 1);
    }
    <SPAN class="comment">/**
    Load model parameters from an Xml file.
    @param file Name of input file
    @param lobseq Length of the observation sequence
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> loadHmmXml(String file, <SPAN class="keyword">int</SPAN> lobseq) {
        lambda.loadModelXml(file);
        len_obseq = lobseq;
        
        alpha = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        beta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        gamma = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        ksi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq-1][getNumStates()][getNumStates()];
        delta = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq][getNumStates()];
        psi = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq][getNumStates()];
        qstar = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
        scaleFactor = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">double</SPAN>[len_obseq];
        obSeq = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
    }

    <SPAN class="comment">/**
    Initializes the model with random parameters.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> initializeModel() {
        initializeModel(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Initializes the model.
    @param bRandomize  If true, initialize the parameters with random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> initializeModel(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        lambda.setProbability(bRandomize);
    }

    <SPAN class="comment">/**
    Sets the observation sequence with random vlaues.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setObSeq() {
        setObSeq(<SPAN class="keyword">true</SPAN>);
    }
    <SPAN class="comment">/**
    Sets the observation sequence.
    @param bRandomize  If true, set the sequence with random values
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setObSeq(<SPAN class="keyword">boolean</SPAN> bRandomize) {
        <SPAN class="keyword">if</SPAN>(bRandomize == <SPAN class="keyword">true</SPAN>) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
                obSeq[t] = (<SPAN class="keyword">int</SPAN>) (getNumSymbols() * rand.nextDouble());
            }    
        }
        <SPAN class="keyword">else</SPAN> {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
                obSeq[t] = 0;
            }    
        }
    }
    <SPAN class="comment">/**
    Sets the observation sequence.
    @param seq  Observation sequence to be assigned
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">void</SPAN> setObSeq(<SPAN class="keyword">int</SPAN>[] seq) {
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            obSeq[t] = seq[t];
        }    
    }
    <SPAN class="comment">/**
    Retrieves the observation symbol at time t.
    @param t  Time at which the observation symbol is to be retrieved
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN> getObSeq(<SPAN class="keyword">int</SPAN> t) {
        <SPAN class="keyword">return</SPAN> obSeq[t];
    }    
    <SPAN class="comment">/**
    Retrieves the observation sequence.
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN>[] getObSeq() {
        <SPAN class="keyword">return</SPAN> obSeq;
    }    

    <SPAN class="comment">/**
    Baum-Welch (EM) algorithm.
    Train the HMM until MIN_ERROR is reached.
    It also stops if the iteration reaches MAX_ITERATION.
    @return  Likelihood of the model given the observation sequence
             after training
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> baumWelchAlgorithm() {
        <SPAN class="keyword">return</SPAN> baumWelchAlgorithm(MIN_ERROR);
    }
    <SPAN class="comment">/**
    Baum-Welch (EM) algorithm.
    Train the HMM until likelihood difference becomes smaller than min_error.
    It also stops if the iteration reaches MAX_ITERATION.
    @param  min_error  Minimum desired error
    @return  Likelihood of the model given the observation sequence
             after training
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> baumWelchAlgorithm(<SPAN class="keyword">double</SPAN> min_error) {
        <SPAN class="keyword">double</SPAN> diff=1.0;
        <SPAN class="keyword">double</SPAN> p1 = forwardBackwardTrellis();
        <SPAN class="keyword">double</SPAN> p2 = 1.0;
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> n=0;n&lt;MAX_ITERATION;n++) {
            reestimateLambda();
            p2 = forwardBackwardTrellis();
            diff = p2 - p1;
            p1 = p2;
            <SPAN class="keyword">if</SPAN>(diff &lt;= min_error) {
                <SPAN class="keyword">break</SPAN>;
            }
        }
        <SPAN class="keyword">return</SPAN> p1;
    }
    
    <SPAN class="comment">/**
    Generates random observation sequence.
    @return  Randomly generated observation sequence according to the model
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN>[] generateSeq() {
        <SPAN class="keyword">int</SPAN>[] seq = <SPAN class="keyword">new</SPAN> <SPAN class="keyword">int</SPAN>[len_obseq];
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;len_obseq;t++) {
            <SPAN class="keyword">double</SPAN> r = rand.nextDouble();
            <SPAN class="keyword">double</SPAN> p = 0.0;
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;getNumSymbols();k++) {
                <SPAN class="keyword">double</SPAN> s = 0.0;
                <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;getNumStates();i++) {
                    s += lambda.getB(i,k) * lambda.getPi(t,i);
                }
                p += s;
                <SPAN class="keyword">if</SPAN>(p &gt; r) {
                    seq[t] = k;
                    <SPAN class="keyword">break</SPAN>;
                }
            }
        }
        <SPAN class="keyword">return</SPAN> seq;
    }
    
    
    <SPAN class="comment">/**
    Three canonical questions of HMM a la Ferguson-Rabiner.
    [1] Given the observation sequence obSeq and a model lambda,
          what is the probability of the given sequence given lambda?
    @return  Probability of the given sequence given lambda
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> getObSeqProbability() {
        <SPAN class="comment">/*
        double logP = Math.log(forwardAlpha());
        for(int t=0;t&lt;len_obseq;t++) {
            logP += Math.log(scaleFactor[t]);
        }
        return logP;
        */</SPAN>
        <SPAN class="keyword">return</SPAN> forwardAlpha();
    }
    
    <SPAN class="comment">/**
    Three canonical questions of HMM a la Ferguson-Rabiner.
    [2] Given the observation sequence obSeq and a model lambda,
          what is the "optimal" sequence of hidden states?
    @return  Most likely sequence of hidden states
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">int</SPAN>[] getMaxLikelyState() {
        viterbiAlgorithm();
        <SPAN class="keyword">return</SPAN> qstar;
    }
    
    <SPAN class="comment">/**
    Three canonical questions of HMM a la Ferguson-Rabiner.
    [3] How do we adjust the model parameters lambda
          to maximize the likelihood of the given sequence obSeq?
    @return Locally optimal likelihood value of the given sequence
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">double</SPAN> optimizeLambda() {
        <SPAN class="keyword">return</SPAN> baumWelchAlgorithm();
    }    
    <SPAN class="comment">//&lt;/Public_Methods&gt;
</SPAN>    
    
    <SPAN class="comment">//&lt;Main_Method&gt;
</SPAN>    <SPAN class="comment">/**
    This function is provided for testing purposes.
    Direct modification of this class is not recommended
    unless there is a bug. (In which case please notify me.)
    Please use inheritance or aggregation (composition).
    */</SPAN>
    <SPAN class="keyword">public</SPAN> <SPAN class="keyword">static</SPAN> <SPAN class="keyword">void</SPAN> main(String[] args) {
    
        Hmm h = <SPAN class="keyword">new</SPAN> Hmm(3, 4, 5, 0, 1, <SPAN class="keyword">false</SPAN>);
        
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;h.getNumStates();i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;h.getNumStates();j++) {
                System.out.print(h.lambda.getA(i,j) + <SPAN class="string">"\t"</SPAN>);
            }
            System.out.println();
        }
        System.out.println();
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> j=0;j&lt;h.getNumStates();j++) {
            System.out.print(h.lambda.getPi(j) + <SPAN class="string">"\t"</SPAN>);
        }
        System.out.println();
        System.out.println();
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> i=0;i&lt;h.getNumStates();i++) {
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> k=0;k&lt;h.getNumSymbols();k++) {
                System.out.print(h.lambda.getB(i,k) + <SPAN class="string">"\t"</SPAN>);
            }
            System.out.println();
        }
        System.out.println();
        
        <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> z=0;z&lt;10;z++) {
            <SPAN class="keyword">int</SPAN>[] seq = h.generateSeq();
            <SPAN class="keyword">for</SPAN>(<SPAN class="keyword">int</SPAN> t=0;t&lt;seq.length;t++) {
                System.out.print(seq[t] + <SPAN class="string">"\t"</SPAN>);
            }
            System.out.println();
        }    
        System.out.println();
        
        <SPAN class="comment">/*
        h.setObSeq();
        for(int t=0;t&lt;h.getLenObSeq();t++) {
            System.out.print(h.getObSeq(t) + "\t");
        }
        System.out.println();
        System.out.println();
        */</SPAN>
        
        <SPAN class="comment">//double p = h.optimizeLambda();
</SPAN>        <SPAN class="comment">//double p = h.getObSeqProbability();
</SPAN>        <SPAN class="comment">//System.out.println(p);
</SPAN>        
    }
    <SPAN class="comment">//&lt;/Main_Method&gt;
</SPAN>}
</PRE>
</BODY></HTML>
